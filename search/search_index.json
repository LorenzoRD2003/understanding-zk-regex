{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Understanding ZK Regex If you are not sure what a regular expression or a DFA are, we strongly recommend you to visit the Concepts page. Use Zero-Knowledge Proofs and regular expressions to validate strings. An arithmetic circuit is generated using Circom. Reasonable uses for this include verifying that a string (as a piece of information) follows specific patterns without revealing its content. Keep in mind that it is not possible to verify all possibilities for an infinite or excessively large language. Additionally, if we send the string to a smart contract, the \"secret\" information would be leaked (similar to how it would with IPFS). In particular, the protocol is programmed in Rust and there are two high-level relevant steps: Convert the regular expression into a deterministic finite automaton (DFA), ideally minimal, using techniques of Language Theory. The goal is to preserve the parts indicated as secret in the regular expression as secret in the DFA. Remember that formally a DFA is a 5 -uple M = \\langle Q, \\Sigma, \\delta, q_0, F \\rangle . In this project, different structures are used to represent (and hide) its data, but broadly speaking, it is thought of as a directed graph. Convert the DFA into a Circom circuit. Specifically, from the DFA, a .circom file is generated whose constraints represent the DFA. Useful links ZK Regex ZK Email ZK Regex Graph Visualizer (this is outdated)","title":"Introduction"},{"location":"#understanding-zk-regex","text":"If you are not sure what a regular expression or a DFA are, we strongly recommend you to visit the Concepts page. Use Zero-Knowledge Proofs and regular expressions to validate strings. An arithmetic circuit is generated using Circom. Reasonable uses for this include verifying that a string (as a piece of information) follows specific patterns without revealing its content. Keep in mind that it is not possible to verify all possibilities for an infinite or excessively large language. Additionally, if we send the string to a smart contract, the \"secret\" information would be leaked (similar to how it would with IPFS). In particular, the protocol is programmed in Rust and there are two high-level relevant steps: Convert the regular expression into a deterministic finite automaton (DFA), ideally minimal, using techniques of Language Theory. The goal is to preserve the parts indicated as secret in the regular expression as secret in the DFA. Remember that formally a DFA is a 5 -uple M = \\langle Q, \\Sigma, \\delta, q_0, F \\rangle . In this project, different structures are used to represent (and hide) its data, but broadly speaking, it is thought of as a directed graph. Convert the DFA into a Circom circuit. Specifically, from the DFA, a .circom file is generated whose constraints represent the DFA.","title":"Understanding ZK Regex"},{"location":"#useful-links","text":"ZK Regex ZK Email ZK Regex Graph Visualizer (this is outdated)","title":"Useful links"},{"location":"obtain_circom/","text":"Convert from DFA to a Circom circuit The first function called is fn generate_outputs( regex_and_dfa: &RegexAndDFA, halo2_dir_path: Option<&str>, circom_file_path: Option<&str>, circom_template_name: Option<&str>, num_public_parts: usize, gen_substrs: bool, ) -> Result<(), CompilerError> As we will use Circom for this document, we assume that the halo2_dir_path input is None . The important parameter here is regex_and_dfa , which is a reference to the RegexAndDFA structure generated in the process described in Obtaining the DFA . The other inputs are for us to specify the name of the file path to the .circom output file, the template name of the circuit in Circom, the number of public parts of the regular expression for which we generated the RegexAndDFA structure (although this is only used to generate multiple output file paths in the Halo2 version) and the gen_substrs bool, which purpose is to add substring constraints to the code generated by the following, and in fact most important function, gen_circom_allstr . fn gen_circom_allstr( // every other parameter except for the template comes from the RegexAndDFA dfa_graph: &DFAGraph, template_name: &str, // name of the Circom template regex_str: &str, end_anchor: bool, ) -> String (yes, all the Circom code will be in a very big string that can be saved as a .circom file) The dfa_graph , regex_str and end_anchor parameters are references to parts of the RegexAndDFA structure generated in the the process described in Obtaining the DFA . Generate the reverse graph of dfa_graph Given a directed graph G = (V, E) , the reverse graph G^r = (V, E^r) is the directed graph with its edges reversed. This means that there exists an edge u \\to v \\in E if and only if there exists an edge v \\to u \\in E^r . In a DFA M with graph representation, it is not so simple to construct a reverse DFA M^r , because we also need to assert there is only one starting state in M^r , and there may be multiple accepting states in M . It is possible to solve this, by creating an extra node with \\lambda -transitions to each of the accepting states in M and setting this at the starting node in M^r . However, the obtained structure is a NFA, and we have to determinize it. We have explained this because it important to address that this is what the build_reverse_graph function DOES NOT DO, as it only reverts the edges of a (multi)graph and collects the accepting states of the dfa_graph . The build_reverse_graph function recieves both the number of states and the dfa_graph and returns both the reverse graph (as a Map<usize, Map<usize, Vec<u8>>> ) and the accepting states (as a Set<usize> ). It is important to understand what this structure represents, as it maps the ID of a state q \\in Q to the IDs of the states Q' \\subseteq Q from which it recieved a transition in the dfa_graph , and it represents each of these states q' \\in Q' as a map from their ID to a vector with the characters that allowed the transition q' \\to q in the dfa_graph . Finally, the function also checks there exists an accepting state in the graph, panicking if not. Generate the state transition logic Given the reverse graph rev_graph , the generate_state_transition_logic function creates the core logic for state transitions in the DFA, including range checks, equality checks, and multi-OR operations. In particular, it creates multiple lines of Circom code with calls to the basic components used. These components can be found in the Concepts section. In fact, this function returns lots of things in a tuple: - The number of IsEqual checks used. - The number of LessEqThan checks used. - The number of AND gates used. - The number of MultiOR gates used. - A Vec<String> containing the generated Circom code lines. This is the most important output of the function. This function is very complex and its explanation will be divided in many subsections. Initialize counters and data structures for different types of checks It defines mutable variables for the values that will be returned as output of the function, which are counters for the amount of gates of each type: The number of IsEqual checks used. The number of LessEqThan checks used. The number of AND gates used. The number of MultiOR gates used. It also defines the following mutable data structures: range_checks as a Vec<Vec<usize; 256>; 256> (in fact, with Option ) eq_checks as a Vec<usize; 256> (in fact, with Option ) multi_or_checks1 as a Map<String, usize> multi_or_checks2 as Map<String, usize> zero_starting_states as a Vec<usize> zero_starting_and_idxes as a Map<usize, Vec<usize>> lines as a Vec<String> . It just has every line of the .circom main component generated by this function. A bit about how the Circom circuit will have We consider that there are n states in the DFA and that the message to validate with the regular expression is a string s of length k (with starting anchor ^ ). Then, we will have the following signals in[k] as the input signals. We will have one for each character, where its value will be from 0 to 255 . states[k + 1][n] , which represent the state transitions based on the input. In fact, at the beginning it will be states[0][j] = 0 \\forall 0 \\leq j < n , and we will calculate states[i][j] = 1 if and only if \\delta(s_i, q_{j-1}) = q_j \\forall 0 \\leq i \\leq k, , which will translate to different code depending on the transition function context. states_tmp[k + 1][n] , which is a helper signal to handle complicated conditions. We will address where it is used. state_changed[k] that will have a boolean in the position i if there was progress when processing the i -th character of the string. This means we changed the state correctly. For this to happen, we need to have success at using the comparison components explained in Concepts to check if an input matches a character, a set of characters, or a range. from_zero_enabled[k + 1] , which checks that after processing the i -th character we are in the initial (zero) state. For example, one of its uses is that if we have from_zero_enabled[i] = 1 and we are able to transition from state 0 to 1 , we have to go to state 1 directly. is_consecutive[k + 1][n - 1] , which address the question of keeping track of whether the matches are consecutive across the input, ensuring that patterns requiring consecutive elements are correctly validated. final_state_result , which is the output signal that is 0 or 1 depending if at some moment we managet to get to the UNIQUE final state of the DFA. One example that usually appears in the code is that \\text{state_changed}[i] = \\bigwedge_{i=1}^{n} \\text{states}[i + 1][j] is implemented as an AND(n - 1) component, which means that we change the state in the i -th step if we transition when we are reading the i -th element, something that is addressed in the (i+1) -th row of states . TODO: Add a simple example (regular expression a[bc][de]*f and input abcdedef ). Remember that not every DFA M will have a topologically sorted graph (i.e. it may have cycles), so it is not as sequential as we want it to be. Generate the Circom code for each state in the DFA We will use the following auxiliar functions for each state in the DFA (going sequentially from 0 up to n - 1 ): Not an auxiliar function, but it updates the zero_starting_states and zero_starting_and_idxes data structures for the current state in the DFA. optimize_char_ranges : add_range_check : add_eq_check : add_state_transition : add_state_update : add_from_zero_enabled : add_zero_starting_state_updates : add_state_changed_updates : Generate the bureaucratic Circom code The function generate_declarations adds everything that every .circom circuit should have, for example the pragma , the include declarations and the circuit template. However, there will have to be many parameters inside the template (for numerating the amount of components for each type of gates), and there is where we use the parameters recieved by the generate_state_transition_logic function. The function generate_init_code generates the initialization code for the Circom circuit, by creating the code to initialize all states except the first one to 0. The function generate_accept_logic recieves the set of accepting nodes and the boolean indicating if there is an ending anchor, and generates the acceptance logic for the Circom circuit. In particular, this function creates the code to check if the DFA has reached an accepting state, and handles the ending anchor logic in the case it is present. Unless there is exactly one accepting node, it will panic (this is supposed to be enhanced in future ZK Regex versions). Combine all the generated Circom code and return. The final code is a String generated by the concatenation of the following vectors of strings: declarations , returned by the generate_declarations function. init_code , returned by the generate_init_code function. lines , returned by the generate_state_transition_logic function. accept_lines , returned by the generate_accept_logic function. And it will be saved as a .circom file so everyone can use it!","title":"Obtaining the Circuit"},{"location":"obtain_circom/#convert-from-dfa-to-a-circom-circuit","text":"The first function called is fn generate_outputs( regex_and_dfa: &RegexAndDFA, halo2_dir_path: Option<&str>, circom_file_path: Option<&str>, circom_template_name: Option<&str>, num_public_parts: usize, gen_substrs: bool, ) -> Result<(), CompilerError> As we will use Circom for this document, we assume that the halo2_dir_path input is None . The important parameter here is regex_and_dfa , which is a reference to the RegexAndDFA structure generated in the process described in Obtaining the DFA . The other inputs are for us to specify the name of the file path to the .circom output file, the template name of the circuit in Circom, the number of public parts of the regular expression for which we generated the RegexAndDFA structure (although this is only used to generate multiple output file paths in the Halo2 version) and the gen_substrs bool, which purpose is to add substring constraints to the code generated by the following, and in fact most important function, gen_circom_allstr . fn gen_circom_allstr( // every other parameter except for the template comes from the RegexAndDFA dfa_graph: &DFAGraph, template_name: &str, // name of the Circom template regex_str: &str, end_anchor: bool, ) -> String (yes, all the Circom code will be in a very big string that can be saved as a .circom file) The dfa_graph , regex_str and end_anchor parameters are references to parts of the RegexAndDFA structure generated in the the process described in Obtaining the DFA .","title":"Convert from DFA to a Circom circuit"},{"location":"obtain_circom/#generate-the-reverse-graph-of-dfa_graph","text":"Given a directed graph G = (V, E) , the reverse graph G^r = (V, E^r) is the directed graph with its edges reversed. This means that there exists an edge u \\to v \\in E if and only if there exists an edge v \\to u \\in E^r . In a DFA M with graph representation, it is not so simple to construct a reverse DFA M^r , because we also need to assert there is only one starting state in M^r , and there may be multiple accepting states in M . It is possible to solve this, by creating an extra node with \\lambda -transitions to each of the accepting states in M and setting this at the starting node in M^r . However, the obtained structure is a NFA, and we have to determinize it. We have explained this because it important to address that this is what the build_reverse_graph function DOES NOT DO, as it only reverts the edges of a (multi)graph and collects the accepting states of the dfa_graph . The build_reverse_graph function recieves both the number of states and the dfa_graph and returns both the reverse graph (as a Map<usize, Map<usize, Vec<u8>>> ) and the accepting states (as a Set<usize> ). It is important to understand what this structure represents, as it maps the ID of a state q \\in Q to the IDs of the states Q' \\subseteq Q from which it recieved a transition in the dfa_graph , and it represents each of these states q' \\in Q' as a map from their ID to a vector with the characters that allowed the transition q' \\to q in the dfa_graph . Finally, the function also checks there exists an accepting state in the graph, panicking if not.","title":"Generate the reverse graph of dfa_graph"},{"location":"obtain_circom/#generate-the-state-transition-logic","text":"Given the reverse graph rev_graph , the generate_state_transition_logic function creates the core logic for state transitions in the DFA, including range checks, equality checks, and multi-OR operations. In particular, it creates multiple lines of Circom code with calls to the basic components used. These components can be found in the Concepts section. In fact, this function returns lots of things in a tuple: - The number of IsEqual checks used. - The number of LessEqThan checks used. - The number of AND gates used. - The number of MultiOR gates used. - A Vec<String> containing the generated Circom code lines. This is the most important output of the function. This function is very complex and its explanation will be divided in many subsections.","title":"Generate the state transition logic"},{"location":"obtain_circom/#initialize-counters-and-data-structures-for-different-types-of-checks","text":"It defines mutable variables for the values that will be returned as output of the function, which are counters for the amount of gates of each type: The number of IsEqual checks used. The number of LessEqThan checks used. The number of AND gates used. The number of MultiOR gates used. It also defines the following mutable data structures: range_checks as a Vec<Vec<usize; 256>; 256> (in fact, with Option ) eq_checks as a Vec<usize; 256> (in fact, with Option ) multi_or_checks1 as a Map<String, usize> multi_or_checks2 as Map<String, usize> zero_starting_states as a Vec<usize> zero_starting_and_idxes as a Map<usize, Vec<usize>> lines as a Vec<String> . It just has every line of the .circom main component generated by this function.","title":"Initialize counters and data structures for different types of checks"},{"location":"obtain_circom/#a-bit-about-how-the-circom-circuit-will-have","text":"We consider that there are n states in the DFA and that the message to validate with the regular expression is a string s of length k (with starting anchor ^ ). Then, we will have the following signals in[k] as the input signals. We will have one for each character, where its value will be from 0 to 255 . states[k + 1][n] , which represent the state transitions based on the input. In fact, at the beginning it will be states[0][j] = 0 \\forall 0 \\leq j < n , and we will calculate states[i][j] = 1 if and only if \\delta(s_i, q_{j-1}) = q_j \\forall 0 \\leq i \\leq k, , which will translate to different code depending on the transition function context. states_tmp[k + 1][n] , which is a helper signal to handle complicated conditions. We will address where it is used. state_changed[k] that will have a boolean in the position i if there was progress when processing the i -th character of the string. This means we changed the state correctly. For this to happen, we need to have success at using the comparison components explained in Concepts to check if an input matches a character, a set of characters, or a range. from_zero_enabled[k + 1] , which checks that after processing the i -th character we are in the initial (zero) state. For example, one of its uses is that if we have from_zero_enabled[i] = 1 and we are able to transition from state 0 to 1 , we have to go to state 1 directly. is_consecutive[k + 1][n - 1] , which address the question of keeping track of whether the matches are consecutive across the input, ensuring that patterns requiring consecutive elements are correctly validated. final_state_result , which is the output signal that is 0 or 1 depending if at some moment we managet to get to the UNIQUE final state of the DFA. One example that usually appears in the code is that \\text{state_changed}[i] = \\bigwedge_{i=1}^{n} \\text{states}[i + 1][j] is implemented as an AND(n - 1) component, which means that we change the state in the i -th step if we transition when we are reading the i -th element, something that is addressed in the (i+1) -th row of states . TODO: Add a simple example (regular expression a[bc][de]*f and input abcdedef ). Remember that not every DFA M will have a topologically sorted graph (i.e. it may have cycles), so it is not as sequential as we want it to be.","title":"A bit about how the Circom circuit will have"},{"location":"obtain_circom/#generate-the-circom-code-for-each-state-in-the-dfa","text":"We will use the following auxiliar functions for each state in the DFA (going sequentially from 0 up to n - 1 ): Not an auxiliar function, but it updates the zero_starting_states and zero_starting_and_idxes data structures for the current state in the DFA. optimize_char_ranges : add_range_check : add_eq_check : add_state_transition : add_state_update : add_from_zero_enabled : add_zero_starting_state_updates : add_state_changed_updates :","title":"Generate the Circom code for each state in the DFA"},{"location":"obtain_circom/#generate-the-bureaucratic-circom-code","text":"The function generate_declarations adds everything that every .circom circuit should have, for example the pragma , the include declarations and the circuit template. However, there will have to be many parameters inside the template (for numerating the amount of components for each type of gates), and there is where we use the parameters recieved by the generate_state_transition_logic function. The function generate_init_code generates the initialization code for the Circom circuit, by creating the code to initialize all states except the first one to 0. The function generate_accept_logic recieves the set of accepting nodes and the boolean indicating if there is an ending anchor, and generates the acceptance logic for the Circom circuit. In particular, this function creates the code to check if the DFA has reached an accepting state, and handles the ending anchor logic in the case it is present. Unless there is exactly one accepting node, it will panic (this is supposed to be enhanced in future ZK Regex versions).","title":"Generate the bureaucratic Circom code"},{"location":"obtain_circom/#combine-all-the-generated-circom-code-and-return","text":"The final code is a String generated by the concatenation of the following vectors of strings: declarations , returned by the generate_declarations function. init_code , returned by the generate_init_code function. lines , returned by the generate_state_transition_logic function. accept_lines , returned by the generate_accept_logic function. And it will be saved as a .circom file so everyone can use it!","title":"Combine all the generated Circom code and return."},{"location":"obtain_dfa/","text":"Convert from regex to DFA fn get_regex_and_dfa( decomposed_regex: &mut DecomposedRegexConfig, // regex parts ) -> Result<RegexAndDFA, CompilerError> The purpose of this function if to obtain the main structure than the function which will convert from DFA to Circom code will use. Refer to the Structures page for understanding its design. Initialize all the (mutable) structures to be used A DFAGraph with an empty vector of states. This is called net_dfa_graph , because later we will loop through the decomposed_regex , creating a new DFAGraph for each part of the regular expression and concatenating it to the network. Two empty vectors for the substring_ranges and substring_boundaries arrays of SubstringDefinitions . A default configuration for the DFA ( create_dfa_config function), it is a Config object as defined in the regex_automata::dfa Rust crate. Particularly, it states that the generated DFA should be minimized, that it should start anchored (i.e. with a starting anchor ^ ), that it will not have byte classes, and that it will have acceleration enabled. Search for the first caret This is achieved by the process_caret_in_regex function. Search for the first caret ^ that is not within parentheses in the regular expression, if there is one (it is an Option<usize> indicating the position of the symbol within the regular expression, so if there does not exist, it will return None ). If it exists, divide the regular expression into two parts, before (non-inclusive) and after (inclusive) the caret (and updating the Deque in the decomposed_regex accordingly). The regular expression part before the caret will be set to private, so it will be guaranteed that the second element of the Deque is a regular expression part which starts with a caret. Remember from the Preconcepts page that a caret in a regular expression matches the start of a line (or in the usual case, the beginning of a regular expression). This is why it is also called a starting anchor , and it means that we should be looking for a match at the beginning of a string. Main cycle For each part of the regular expression in decomposed_regex , do the following: Validate end anchor The important thing to address here is that none of the parts of the decomposed_regex should end with $ except for the last one. Therefore, the validate_end_anchor function checks that if we are not processing the last part in the decomposed_regex , it does not end with $ , and if it is the last part, obtain a bool indicating whether it ends with $ and store this in the RegexAndDFA structure under the property has_end_anchor . Construct the DFA for each part The algorithm constructs a DFA for the part in question. This is done by the DFA::builder() function of the regex_automata::dfa Rust crate, with the particular configuration indicated in a previous subsection. This returns... TODO Transform the DFA into a DFAGraph The algorithm transforms that DFA (represented as a DFA<Vec<u32>> structure of the regex_automata::dfa Rust crate) into a graph using the convert_dfa_to_graph function, obtaining a DFAGraph structured called dfa_graph . In particular, the function does these things: Converts the DFA to a string representation. This is with the format! Rust macro. Creates an empty DFAGraphInfo structure (refer to Structures for more information), which will be populated with the next step. Parses states from the string representation with the parse_states function, which will recieve as parameters mutable references to both the string representation and the DFAGraphInfo structure. This function will be better explained in an update of this documet, but as a resume it uses regular expressions to match state definitions and transitions in the input string, iterating over state matches in order to create DFAStateInfo objects for each state (each node in the graph), then it parses transitions for each state (with the parse_transition ) function to populate the edges of that state, and finally it populates the states parameter of the DFAGraphInfo with the parsed states. Handles End of Input (EOI) transitions. In particular, if an state q has a transition to another through the EOI symbol, it will be removed from the edges, and q will be marked as an accepting state (with the typ property in the DFAStateInfo structure). Finds the start state of the string representation of the DFA using find_start_state , obtaining its ID. Sorts and renames states accordingly given the DFAGraphInfo structure and the start identifier. This is achieved by performing a Performs a BFS (with a queue implemented as a VecDeque ) in the graph from the start state, creating a mapping of old states IDs to new ones, renaming states and updating their edges according to the mapping. This means each DFAStateInfo is modified, but the obtained DFAGraphInfo is equivalent to the original (in the sense that the formal DFA they represent is the same, or at least recognizes the same language). Before converting the DFAGraphInfo structure into a DFAGraph , it has to call the function process_state_edges because the properties for the edges in the DFAGraphInfo and DFAGraph structures are different. It converts from Map<String, usize> to Map<usize, Set<u8>> . In particular, remember that for efficiency, there are two types of edges in DFAGraphInfo , single character edges and range edges, so it has to address these different cases in the process_edge function. With the transitions of the expected type, it converts the DFAGraphInfo structure into a DFAGraph that which will put inside the RegexAndDFA and be used by the Circom code generator. We obtain a dfa_graph (remember that an important property of this structure is that it only has one accepting state). Handle a caret in the first part If there is a caret ^ in the first part of the decomposed_regex , the dfa_graph returned by the previous function is not able to accept the empty string, but it should! Therefore, there is a handle_regex_caret function for this. It addresses two cases: The regex is ^ . In this case the graph generated will be very simple as it only contains two states and one transition from the starting state to the accepting state for the character of byte value 255 . The regex is not ^ . In this case it modifies the dfa_graph by clearing the the state type of its initial state, finding its accepting state and adding a transition from the start state to the accept state for the character of byte value 255 . Rename the states We want to concatenate the new dfa_graph for the current decomposed_regex into the net_dfa_graph , but we want to avoid ID collisions. To achieve this, we have to obtain the highest state ID in the net_dfa_graph . Remember that each ID is just a number, so if the maximum index for net_dfa_graph is m , it is possible to rename the dfa_graph states as [m, m + 1, \\ldots, m + k - 1] if it has k states. If the decomposed_regex part is public... We have to process the regular expression and both the net_dfa_graph and dfa_graph before the concatenation, in a function called process_public_regex . This is to be able to obtain the data needed to be stored by the SubstringDefinitions structure. It is indicated how this works and why it is necessary in the ( SubstringDefinitions subsection in Structures ). Concatenate the graph to the network Effectively concatenate dfa_graph to net_dfa_graph , returning a new DFAGraph which will be saved as the new net_dfa_graph (even though this add_dfa function merely extends the vector of states). Construct the main structure From the parameters obtained, we are able to construct the RegexAndDFA structure (refer to Structures to remember which they are). Specifically, the regular expression stored in the structure is the string concatenation of the parts of the decomposed_regex , while the logic of which parts to keep secret is incorporated into the net_dfa_graph .","title":"Obtaining the DFA"},{"location":"obtain_dfa/#convert-from-regex-to-dfa","text":"fn get_regex_and_dfa( decomposed_regex: &mut DecomposedRegexConfig, // regex parts ) -> Result<RegexAndDFA, CompilerError> The purpose of this function if to obtain the main structure than the function which will convert from DFA to Circom code will use. Refer to the Structures page for understanding its design.","title":"Convert from regex to DFA"},{"location":"obtain_dfa/#initialize-all-the-mutable-structures-to-be-used","text":"A DFAGraph with an empty vector of states. This is called net_dfa_graph , because later we will loop through the decomposed_regex , creating a new DFAGraph for each part of the regular expression and concatenating it to the network. Two empty vectors for the substring_ranges and substring_boundaries arrays of SubstringDefinitions . A default configuration for the DFA ( create_dfa_config function), it is a Config object as defined in the regex_automata::dfa Rust crate. Particularly, it states that the generated DFA should be minimized, that it should start anchored (i.e. with a starting anchor ^ ), that it will not have byte classes, and that it will have acceleration enabled.","title":"Initialize all the (mutable) structures to be used"},{"location":"obtain_dfa/#search-for-the-first-caret","text":"This is achieved by the process_caret_in_regex function. Search for the first caret ^ that is not within parentheses in the regular expression, if there is one (it is an Option<usize> indicating the position of the symbol within the regular expression, so if there does not exist, it will return None ). If it exists, divide the regular expression into two parts, before (non-inclusive) and after (inclusive) the caret (and updating the Deque in the decomposed_regex accordingly). The regular expression part before the caret will be set to private, so it will be guaranteed that the second element of the Deque is a regular expression part which starts with a caret. Remember from the Preconcepts page that a caret in a regular expression matches the start of a line (or in the usual case, the beginning of a regular expression). This is why it is also called a starting anchor , and it means that we should be looking for a match at the beginning of a string.","title":"Search for the first caret"},{"location":"obtain_dfa/#main-cycle","text":"For each part of the regular expression in decomposed_regex , do the following:","title":"Main cycle"},{"location":"obtain_dfa/#validate-end-anchor","text":"The important thing to address here is that none of the parts of the decomposed_regex should end with $ except for the last one. Therefore, the validate_end_anchor function checks that if we are not processing the last part in the decomposed_regex , it does not end with $ , and if it is the last part, obtain a bool indicating whether it ends with $ and store this in the RegexAndDFA structure under the property has_end_anchor .","title":"Validate end anchor"},{"location":"obtain_dfa/#construct-the-dfa-for-each-part","text":"The algorithm constructs a DFA for the part in question. This is done by the DFA::builder() function of the regex_automata::dfa Rust crate, with the particular configuration indicated in a previous subsection. This returns... TODO","title":"Construct the DFA for each part"},{"location":"obtain_dfa/#transform-the-dfa-into-a-dfagraph","text":"The algorithm transforms that DFA (represented as a DFA<Vec<u32>> structure of the regex_automata::dfa Rust crate) into a graph using the convert_dfa_to_graph function, obtaining a DFAGraph structured called dfa_graph . In particular, the function does these things: Converts the DFA to a string representation. This is with the format! Rust macro. Creates an empty DFAGraphInfo structure (refer to Structures for more information), which will be populated with the next step. Parses states from the string representation with the parse_states function, which will recieve as parameters mutable references to both the string representation and the DFAGraphInfo structure. This function will be better explained in an update of this documet, but as a resume it uses regular expressions to match state definitions and transitions in the input string, iterating over state matches in order to create DFAStateInfo objects for each state (each node in the graph), then it parses transitions for each state (with the parse_transition ) function to populate the edges of that state, and finally it populates the states parameter of the DFAGraphInfo with the parsed states. Handles End of Input (EOI) transitions. In particular, if an state q has a transition to another through the EOI symbol, it will be removed from the edges, and q will be marked as an accepting state (with the typ property in the DFAStateInfo structure). Finds the start state of the string representation of the DFA using find_start_state , obtaining its ID. Sorts and renames states accordingly given the DFAGraphInfo structure and the start identifier. This is achieved by performing a Performs a BFS (with a queue implemented as a VecDeque ) in the graph from the start state, creating a mapping of old states IDs to new ones, renaming states and updating their edges according to the mapping. This means each DFAStateInfo is modified, but the obtained DFAGraphInfo is equivalent to the original (in the sense that the formal DFA they represent is the same, or at least recognizes the same language). Before converting the DFAGraphInfo structure into a DFAGraph , it has to call the function process_state_edges because the properties for the edges in the DFAGraphInfo and DFAGraph structures are different. It converts from Map<String, usize> to Map<usize, Set<u8>> . In particular, remember that for efficiency, there are two types of edges in DFAGraphInfo , single character edges and range edges, so it has to address these different cases in the process_edge function. With the transitions of the expected type, it converts the DFAGraphInfo structure into a DFAGraph that which will put inside the RegexAndDFA and be used by the Circom code generator. We obtain a dfa_graph (remember that an important property of this structure is that it only has one accepting state).","title":"Transform the DFA into a DFAGraph"},{"location":"obtain_dfa/#handle-a-caret-in-the-first-part","text":"If there is a caret ^ in the first part of the decomposed_regex , the dfa_graph returned by the previous function is not able to accept the empty string, but it should! Therefore, there is a handle_regex_caret function for this. It addresses two cases: The regex is ^ . In this case the graph generated will be very simple as it only contains two states and one transition from the starting state to the accepting state for the character of byte value 255 . The regex is not ^ . In this case it modifies the dfa_graph by clearing the the state type of its initial state, finding its accepting state and adding a transition from the start state to the accept state for the character of byte value 255 .","title":"Handle a caret in the first part"},{"location":"obtain_dfa/#rename-the-states","text":"We want to concatenate the new dfa_graph for the current decomposed_regex into the net_dfa_graph , but we want to avoid ID collisions. To achieve this, we have to obtain the highest state ID in the net_dfa_graph . Remember that each ID is just a number, so if the maximum index for net_dfa_graph is m , it is possible to rename the dfa_graph states as [m, m + 1, \\ldots, m + k - 1] if it has k states.","title":"Rename the states"},{"location":"obtain_dfa/#if-the-decomposed_regex-part-is-public","text":"We have to process the regular expression and both the net_dfa_graph and dfa_graph before the concatenation, in a function called process_public_regex . This is to be able to obtain the data needed to be stored by the SubstringDefinitions structure. It is indicated how this works and why it is necessary in the ( SubstringDefinitions subsection in Structures ).","title":"If the decomposed_regex part is public..."},{"location":"obtain_dfa/#concatenate-the-graph-to-the-network","text":"Effectively concatenate dfa_graph to net_dfa_graph , returning a new DFAGraph which will be saved as the new net_dfa_graph (even though this add_dfa function merely extends the vector of states).","title":"Concatenate the graph to the network"},{"location":"obtain_dfa/#construct-the-main-structure","text":"From the parameters obtained, we are able to construct the RegexAndDFA structure (refer to Structures to remember which they are). Specifically, the regular expression stored in the structure is the string concatenation of the parts of the decomposed_regex , while the logic of which parts to keep secret is incorporated into the net_dfa_graph .","title":"Construct the main structure"},{"location":"preconcepts/","text":"Preconcepts Regular Expressions A regular expression r is a sequence of characters that defines a search pattern. We say that, given an alphabet \\Sigma a regular expression describes a language \\mathcal{L} \\subseteq \\Sigma . Regular expressions are used primarily for string pattern matching and manipulation. Outside of the Zero-Knowledge world, they have worked as powerful tools for: Searching for specific patterns within a text. For example, you might use a regex to find all occurrences of email addresses in a document. Substituting one pattern with another. For instance, you could use a regex to replace all instances of a specific word with a new one. Checking if a string matches a predefined format, such as ensuring an input is a valid phone number or email address. Breaking a string into substrings based on a pattern. For example, splitting a CSV string into its component values. The standards for regular expression notation (and in fact, the notation recognized by this converter) are determined by literals, metacharacters, quantifiers, anchors, character classes and groups. In particular, they are defined by: A \\ followed by a character that is not a newline matches that character. This includes all special characters. A caret ^ matches the start of a line. It is also called a starting anchor A dollar sign $ matches the end of a line. It is also called an ending anchor . A dot . matches any character. A single character that has no special meaning matches that character. A string enclosed in square brackets [] matches any character in the string. ASCII characters can also be abbreviated as a-z0-9 . If a ^ is the first character inside the brackets, it matches any character that is NOT inside the brackets. A regular expression followed by an asterisk * matches a sequence of zero or more occurrences of the regular expression. A regular expression followed by a plus sign + matches a sequence of one or more occurrences of the regular expression. A regular expression followed by a question mark ? matches a sequence of zero or one occurrence of the regular expression. Two concatenated regular expressions match an occurrence of the first followed by one of the second. Two regular expressions separated by a pipe | match an occurrence of the first or the second. Parentheses are used to group a regular expression (and then apply special characters as needed). Using @ makes the regular expressions case-sensitive. Using ~ makes the regular expressions case-insensitive. Example of a regular expression Consider a regular expression that recognizes strings containing an even number of 1 s: r = 0^*(10^*10^*)^* Deterministic Finite Automaton (DFA) It is a theoretical model used in computer science to represent and recognize patterns or sequences of symbols. It can be formalized as a 5 -uple M = \\langle Q, \\Sigma, \\delta, q_0, F \\rangle where: Q is the (finite) set of states . Sigma is the input alphabet , i.e. set of symbols that the DFA can read. For example, in a DFA designed to recognize binary numbers, the input alphabet would be \\Sigma = \\{0, 1\\} . \\delta: Q \\times \\Sigma \\to Q is the transition function . It maps a state and an input symbol to the next state. This function is defined for every combination of states and input symbols. The important thing it that it is deterministic , this means the automaton has a single and well-defined path to follow for each input string. q_0 is the initial state . Every time M starts processing a string, it begins from this state. F \\subseteq Q is the set of accepting states . This states define that if the automaton ends up after processing the input string, the string is considered accepted. A DFA M recieves an input string s \\in \\Sigma^* (where \\Sigma ^* is the Kleene clause of Sigma ), and processes it from its initial state using its transition function. If at the end, we are at one of the accepting states, the string is considered recognized by the DFA. Therefore, we can formally define the recognized language of M as the set of strings that recognizes, by \\mathcal{L}(M) = \\{s \\in \\Sigma^*: \\delta(q_0, s) \\in F\\} where we are abusing notation to allow \\delta recognize strings and not only characters. Remember that a DFA is a theoretical model. When we implement it, we can allow more freedom or restrictions according to out neccesities. For example, the DFAs generated by ZK Regex have the additional restriction of only having one accepting state ( |F| = 1 ). We also encourage to think the transition function of a DFA as a graph, where the states are nodes and reading a character represents an edge. Another useful algorithm is DFA minimization. For every DFA M , there exists another DFA M' such that \\mathcal{L}(M) = \\mathcal{L}(M') and M' has the least possible amount of states. ZK Regex just uses the same algorithm provided by the DFA Rust crate. Example of a DFA Consider a simple DFA that recognizes binary strings containing an even number of 1 s: M = \\langle \\{q_0, q_1\\}, \\{0, 1\\}, \\delta, q_0, \\{q_0\\}\\rangle The automaton is in the state q_0 when it has recieved an even number of 1 s (that is why it is an accepting state), and it is in the state q_1 when it has recieved an odd number of 1 s. Of course, its transition function is given by: \\delta(q_0, 0) = q_0 \\delta(q_0, 1) = q_1 \\delta(q_1, 0) = q_1 \\delta(q_1, 1) = q_0 Relation between regular expressions and DFA The main result is that regular expressions and DFA are equivalent. This means that given any regular expression, you can construct a DFA that accepts the same language described by that regular expression. And conversely, for every DFA, there exists a regular expression that describes the language accepted by that DFA. This means that the set of strings accepted by a DFA can be expressed by some regular expression. And in fact, this result is proven by construction! This means we know algorithms that can do this. In particular, the first part of ZK Regex works by converting a regular expression to a DFA. The difference is that there is more data, as described in the Structures page, that describes which sections of a regular expression must be public parameters or private parameters in the final circuit. Usually, the basic algorithm involves several steps: Converting Regex to NFA (Non-Deterministic Finite Automaton). Converting NFA to DFA. There does exist crates for the basic algorithm and structures in Rust, but the algorithm needs to be modified because of the cryptographic requirements of ZK Regex. Refer to the Obtaining DFA page for more information about this implementation. Circom Circuits TODO IsEqual LessEqualThan AND MultiOR Useful links DFA Regular Expressions Experiment with regex! PDF about theory of Automatons and Regular Expressions","title":"Concepts"},{"location":"preconcepts/#preconcepts","text":"","title":"Preconcepts"},{"location":"preconcepts/#regular-expressions","text":"A regular expression r is a sequence of characters that defines a search pattern. We say that, given an alphabet \\Sigma a regular expression describes a language \\mathcal{L} \\subseteq \\Sigma . Regular expressions are used primarily for string pattern matching and manipulation. Outside of the Zero-Knowledge world, they have worked as powerful tools for: Searching for specific patterns within a text. For example, you might use a regex to find all occurrences of email addresses in a document. Substituting one pattern with another. For instance, you could use a regex to replace all instances of a specific word with a new one. Checking if a string matches a predefined format, such as ensuring an input is a valid phone number or email address. Breaking a string into substrings based on a pattern. For example, splitting a CSV string into its component values. The standards for regular expression notation (and in fact, the notation recognized by this converter) are determined by literals, metacharacters, quantifiers, anchors, character classes and groups. In particular, they are defined by: A \\ followed by a character that is not a newline matches that character. This includes all special characters. A caret ^ matches the start of a line. It is also called a starting anchor A dollar sign $ matches the end of a line. It is also called an ending anchor . A dot . matches any character. A single character that has no special meaning matches that character. A string enclosed in square brackets [] matches any character in the string. ASCII characters can also be abbreviated as a-z0-9 . If a ^ is the first character inside the brackets, it matches any character that is NOT inside the brackets. A regular expression followed by an asterisk * matches a sequence of zero or more occurrences of the regular expression. A regular expression followed by a plus sign + matches a sequence of one or more occurrences of the regular expression. A regular expression followed by a question mark ? matches a sequence of zero or one occurrence of the regular expression. Two concatenated regular expressions match an occurrence of the first followed by one of the second. Two regular expressions separated by a pipe | match an occurrence of the first or the second. Parentheses are used to group a regular expression (and then apply special characters as needed). Using @ makes the regular expressions case-sensitive. Using ~ makes the regular expressions case-insensitive.","title":"Regular Expressions"},{"location":"preconcepts/#example-of-a-regular-expression","text":"Consider a regular expression that recognizes strings containing an even number of 1 s: r = 0^*(10^*10^*)^*","title":"Example of a regular expression"},{"location":"preconcepts/#deterministic-finite-automaton-dfa","text":"It is a theoretical model used in computer science to represent and recognize patterns or sequences of symbols. It can be formalized as a 5 -uple M = \\langle Q, \\Sigma, \\delta, q_0, F \\rangle where: Q is the (finite) set of states . Sigma is the input alphabet , i.e. set of symbols that the DFA can read. For example, in a DFA designed to recognize binary numbers, the input alphabet would be \\Sigma = \\{0, 1\\} . \\delta: Q \\times \\Sigma \\to Q is the transition function . It maps a state and an input symbol to the next state. This function is defined for every combination of states and input symbols. The important thing it that it is deterministic , this means the automaton has a single and well-defined path to follow for each input string. q_0 is the initial state . Every time M starts processing a string, it begins from this state. F \\subseteq Q is the set of accepting states . This states define that if the automaton ends up after processing the input string, the string is considered accepted. A DFA M recieves an input string s \\in \\Sigma^* (where \\Sigma ^* is the Kleene clause of Sigma ), and processes it from its initial state using its transition function. If at the end, we are at one of the accepting states, the string is considered recognized by the DFA. Therefore, we can formally define the recognized language of M as the set of strings that recognizes, by \\mathcal{L}(M) = \\{s \\in \\Sigma^*: \\delta(q_0, s) \\in F\\} where we are abusing notation to allow \\delta recognize strings and not only characters. Remember that a DFA is a theoretical model. When we implement it, we can allow more freedom or restrictions according to out neccesities. For example, the DFAs generated by ZK Regex have the additional restriction of only having one accepting state ( |F| = 1 ). We also encourage to think the transition function of a DFA as a graph, where the states are nodes and reading a character represents an edge. Another useful algorithm is DFA minimization. For every DFA M , there exists another DFA M' such that \\mathcal{L}(M) = \\mathcal{L}(M') and M' has the least possible amount of states. ZK Regex just uses the same algorithm provided by the DFA Rust crate.","title":"Deterministic Finite Automaton (DFA)"},{"location":"preconcepts/#example-of-a-dfa","text":"Consider a simple DFA that recognizes binary strings containing an even number of 1 s: M = \\langle \\{q_0, q_1\\}, \\{0, 1\\}, \\delta, q_0, \\{q_0\\}\\rangle The automaton is in the state q_0 when it has recieved an even number of 1 s (that is why it is an accepting state), and it is in the state q_1 when it has recieved an odd number of 1 s. Of course, its transition function is given by: \\delta(q_0, 0) = q_0 \\delta(q_0, 1) = q_1 \\delta(q_1, 0) = q_1 \\delta(q_1, 1) = q_0","title":"Example of a DFA"},{"location":"preconcepts/#relation-between-regular-expressions-and-dfa","text":"The main result is that regular expressions and DFA are equivalent. This means that given any regular expression, you can construct a DFA that accepts the same language described by that regular expression. And conversely, for every DFA, there exists a regular expression that describes the language accepted by that DFA. This means that the set of strings accepted by a DFA can be expressed by some regular expression. And in fact, this result is proven by construction! This means we know algorithms that can do this. In particular, the first part of ZK Regex works by converting a regular expression to a DFA. The difference is that there is more data, as described in the Structures page, that describes which sections of a regular expression must be public parameters or private parameters in the final circuit. Usually, the basic algorithm involves several steps: Converting Regex to NFA (Non-Deterministic Finite Automaton). Converting NFA to DFA. There does exist crates for the basic algorithm and structures in Rust, but the algorithm needs to be modified because of the cryptographic requirements of ZK Regex. Refer to the Obtaining DFA page for more information about this implementation.","title":"Relation between regular expressions and DFA"},{"location":"preconcepts/#circom-circuits","text":"TODO","title":"Circom Circuits"},{"location":"preconcepts/#isequal","text":"","title":"IsEqual"},{"location":"preconcepts/#lessequalthan","text":"","title":"LessEqualThan"},{"location":"preconcepts/#and","text":"","title":"AND"},{"location":"preconcepts/#multior","text":"","title":"MultiOR"},{"location":"preconcepts/#useful-links","text":"DFA Regular Expressions Experiment with regex! PDF about theory of Automatons and Regular Expressions","title":"Useful links"},{"location":"structures/","text":"Structures All this structures derive the traits Debug and Clone . Besides, they are all serializable (using the serde crate) except from the structures that have the prefix Info . In general, every Map and Set are implemented as BTreeMap and BTreeSet , while every Deque is implemented as VecDeque , but for simplicity of functionalities we will refer to them as the basic names in this document. Main structure pub struct RegexAndDFA { pub regex_pattern: String, pub dfa: DFAGraph, pub has_end_anchor: bool, pub substrings: SubstringsDefinitions } For the creation of the circuit, we need to create the DFA from the regular expression. However, in the main structure we will save both of them. Also, we will have the SubstringsDefinitions for all the public parts. Observe that the regex_pattern is a String . This means that we will concatenate all of the parts given by the JSON input file to the program into a single string. The has_end_anchor means what we expect. Remember from the Concepts page that a dollar sign $ in a regular expression matches the end of a line (or in the usual case, the end of a regular expression). This is why it is also called a end anchor , and it means that we should be looking for a match at the end of a string. Combining it with the starting anchor ^ , it is usual to convert a regex r into ^r$ . In particular, here the puropose of the has_end_anchor boolean is to provide extra information to the Circom code generator. RegexPart pub struct RegexPartConfig { pub is_public: bool, pub regex_def: String } pub struct DecomposedRegexConfig { pub parts: Deque<RegexPartConfig> } The input to the program will be a JSON file containing an object with a single attribute parts , which is an array of objects with the parameters is_public and regex_def (those of the RegexPartConfig structure), from which we construct a DecomposedRegexConfig . An example of a JSON object for input is: { \"parts\": [ { \"regex_def\": \"m[01]+-\", \"is_public\": false }, { \"regex_def\": \"[ab]+\", \"is_public\": true }, { \"regex_def\": \";\", \"is_public\": false } ] } In turn, the input to the function fn get_regex_and_dfa will be a mutable reference to a DecomposedRegexConfig . The idea is for the program to analyze each part of the regular expression separately using the regex_def property. The advantage of having multiple parts of the regular expression is that we can reveal some and keep others hidden (using the is_public property). As a limitation, the division into parts must occur after a step where the regular expression can be written as a concatenation of the parts (i.e., the parts must be valid). For example: The regular expression given by [01]*[ab]+ can be separated in parts in multiple ways, for example: [01]* , [ab] and [ab]* . The regular expression given by [[01]*[ab]*]* cannot be separated in parts in any way. This means it will be completely public or completely private when we generate the code. However, it is important to address that for nearly every useful regular expression, it will be possible to separate it in parts as we want. DFA pub struct DFAStateInfo { pub typ: String, pub source: usize, pub edges: Map<String, usize> } pub struct DFAStateNode { pub state_type: String, pub state_id: usize, pub transitions: Map<usize, Set<u8>> } pub struct DFAGraphInfo { pub states: Vec<DFAStateInfo> } pub struct DFAGraph { pub states: Vec<DFAStateNode> } First of all, let's talk about the DFAGraphInfo structure. It is useful when transitioning from the regex_and_automata::dfa Rust crate structure to the DFAGraph structure. In particular, the properties in a DFAStateInfo have the following meaning: typ has the value \"accept\" if and only if it is an accepting state in the DFA. source is the identifier of the state. edges refer to the transitions from the state to other states in the DFA. Note that the map keys are String . They are interpeted as regular expressions for efficiency, as there can be ranges . So there will be two type of edges, single character edges and range edges (for example, the map could be {(\"A-Z\", 1), (\"a-z\", 2)}, (\"0-9\", 3), (\";\", 4), (\"t\", 5) ). In the algorithm, we will process each `RegexPartConfig and obtain a DFAGraph (in the middle, we will have the DFAGraphInfo ), we will assume that each node in the DFA has an identifier. As we merge the DFAGraph of each part into a single graph called net_dfa_graph , we need to update the set of states, and more importantly, the indices and edges of each node, to avoid index collisions. This renaming must not affect the structure of the DFA. We focus on the DFAStateNode structure: the state_type property indicates whether a state is final, the state_id property indicates the index of the state in the graph, and the transitions property is the set of edges, represented as a Map<usize, Set<u8>> where each node index has a set of valid characters (i.e., a Set<u8> ) that allow the transition. This is different than in the DFA theoretical model, as there the transition function is total, and that means there will need to exist a transition for each character and each state. So when we recieve an invalid character, we go to an error state that only has transitions to itself, and the string is not recognized by the DFA. In the implementation, as it would be too much to have 2^8 = 256 transitions for each character, we have the map, which is essentially a different function for each state q f: Q \\to \\mathcal{P}(\\Sigma) meaning that it maps each possible next state p (given its index) to the set of characters of the alphabet that allow a transition from $q$. It is important that: \\forall p \\neq p' \\in Q, f(p) \\cap f(p') = \\emptyset meaning that in fact the DFA is deterministic. To facilitate the semantic analogy, the code refers to transitions as edges in the remaining functions, without considering the case of a multigraph (remember that in a graph that is not a multigraph, there can only be one edge between two given nodes, and if there is more than one character that allows a transition between two states in the DFA, there will be more than one edge). Substring Definitions pub struct SubstringDefinitions { pub substring_ranges: Vec<Set<(usize, usize)>>, pub substring_boundaries: Option<Vec<(Set(usize), Set(usize))>> } pub struct SubstringDefinitionsJson { pub transitions: Vec<Vec<(usize, usize)>> } The idea is to have a SubstringDefinitions structure for each of the public parts of the regular expression. Consider the context where we are merging a DFA N (the accumulated network) and M (corresponding to a public part). This M will have a range of the type Set<(usize, usize)> and a limit of the type (Set(usize), Set(usize)) . The limit is called so because when merging the network N and the public M , where m is the maximum state index in N , it is understood that m is the \"limit\" between N and M (as the states of M are renamed to have indices \\geq m ). The range indicates the set of public edges in M and is essentially all its edges. That is, a set of pairs of DFAStateNode.state_id . We store this for future use, for the circuit generation. Since m is an index in both DFAs, and particularly the initial state of M , we have the classic DFA concatenation problem: obtaining NM (concatenated) where we can only transition from N to M via m and not from any state in F_N , which is a problem regardless of whether m \\in F_N . The proposed solution is to replace in M each edge that includes m as follows: \\begin{aligned} m \\rightarrow q &\\text{ by } \\{f \\rightarrow q: f \\in F_N\\}, \\quad (q \\in Q_M \\setminus \\{m\\})\\\\ q \\rightarrow m &\\text{ by } \\{q \\rightarrow f: f \\in F_N\\}, \\\\ m \\rightarrow m &\\text{ by } \\{f \\rightarrow f': f,f' \\in F_N\\} \\end{aligned} and the resulting DFA is effectively the concatenation of N and M . The two sets of the limit indicate where the substring of the regular expression corresponding to this part begins and ends. The start is the set of DFAStateNode.state_id generated by the final states of N , and the end is the set generated by the final states of M . Thus, a substring matches this part if and only if when we start, we are in an index from the first set, and when we finish, we are in an index from the second set.","title":"Structures"},{"location":"structures/#structures","text":"All this structures derive the traits Debug and Clone . Besides, they are all serializable (using the serde crate) except from the structures that have the prefix Info . In general, every Map and Set are implemented as BTreeMap and BTreeSet , while every Deque is implemented as VecDeque , but for simplicity of functionalities we will refer to them as the basic names in this document.","title":"Structures"},{"location":"structures/#main-structure","text":"pub struct RegexAndDFA { pub regex_pattern: String, pub dfa: DFAGraph, pub has_end_anchor: bool, pub substrings: SubstringsDefinitions } For the creation of the circuit, we need to create the DFA from the regular expression. However, in the main structure we will save both of them. Also, we will have the SubstringsDefinitions for all the public parts. Observe that the regex_pattern is a String . This means that we will concatenate all of the parts given by the JSON input file to the program into a single string. The has_end_anchor means what we expect. Remember from the Concepts page that a dollar sign $ in a regular expression matches the end of a line (or in the usual case, the end of a regular expression). This is why it is also called a end anchor , and it means that we should be looking for a match at the end of a string. Combining it with the starting anchor ^ , it is usual to convert a regex r into ^r$ . In particular, here the puropose of the has_end_anchor boolean is to provide extra information to the Circom code generator.","title":"Main structure"},{"location":"structures/#regexpart","text":"pub struct RegexPartConfig { pub is_public: bool, pub regex_def: String } pub struct DecomposedRegexConfig { pub parts: Deque<RegexPartConfig> } The input to the program will be a JSON file containing an object with a single attribute parts , which is an array of objects with the parameters is_public and regex_def (those of the RegexPartConfig structure), from which we construct a DecomposedRegexConfig . An example of a JSON object for input is: { \"parts\": [ { \"regex_def\": \"m[01]+-\", \"is_public\": false }, { \"regex_def\": \"[ab]+\", \"is_public\": true }, { \"regex_def\": \";\", \"is_public\": false } ] } In turn, the input to the function fn get_regex_and_dfa will be a mutable reference to a DecomposedRegexConfig . The idea is for the program to analyze each part of the regular expression separately using the regex_def property. The advantage of having multiple parts of the regular expression is that we can reveal some and keep others hidden (using the is_public property). As a limitation, the division into parts must occur after a step where the regular expression can be written as a concatenation of the parts (i.e., the parts must be valid). For example: The regular expression given by [01]*[ab]+ can be separated in parts in multiple ways, for example: [01]* , [ab] and [ab]* . The regular expression given by [[01]*[ab]*]* cannot be separated in parts in any way. This means it will be completely public or completely private when we generate the code. However, it is important to address that for nearly every useful regular expression, it will be possible to separate it in parts as we want.","title":"RegexPart"},{"location":"structures/#dfa","text":"pub struct DFAStateInfo { pub typ: String, pub source: usize, pub edges: Map<String, usize> } pub struct DFAStateNode { pub state_type: String, pub state_id: usize, pub transitions: Map<usize, Set<u8>> } pub struct DFAGraphInfo { pub states: Vec<DFAStateInfo> } pub struct DFAGraph { pub states: Vec<DFAStateNode> } First of all, let's talk about the DFAGraphInfo structure. It is useful when transitioning from the regex_and_automata::dfa Rust crate structure to the DFAGraph structure. In particular, the properties in a DFAStateInfo have the following meaning: typ has the value \"accept\" if and only if it is an accepting state in the DFA. source is the identifier of the state. edges refer to the transitions from the state to other states in the DFA. Note that the map keys are String . They are interpeted as regular expressions for efficiency, as there can be ranges . So there will be two type of edges, single character edges and range edges (for example, the map could be {(\"A-Z\", 1), (\"a-z\", 2)}, (\"0-9\", 3), (\";\", 4), (\"t\", 5) ). In the algorithm, we will process each `RegexPartConfig and obtain a DFAGraph (in the middle, we will have the DFAGraphInfo ), we will assume that each node in the DFA has an identifier. As we merge the DFAGraph of each part into a single graph called net_dfa_graph , we need to update the set of states, and more importantly, the indices and edges of each node, to avoid index collisions. This renaming must not affect the structure of the DFA. We focus on the DFAStateNode structure: the state_type property indicates whether a state is final, the state_id property indicates the index of the state in the graph, and the transitions property is the set of edges, represented as a Map<usize, Set<u8>> where each node index has a set of valid characters (i.e., a Set<u8> ) that allow the transition. This is different than in the DFA theoretical model, as there the transition function is total, and that means there will need to exist a transition for each character and each state. So when we recieve an invalid character, we go to an error state that only has transitions to itself, and the string is not recognized by the DFA. In the implementation, as it would be too much to have 2^8 = 256 transitions for each character, we have the map, which is essentially a different function for each state q f: Q \\to \\mathcal{P}(\\Sigma) meaning that it maps each possible next state p (given its index) to the set of characters of the alphabet that allow a transition from $q$. It is important that: \\forall p \\neq p' \\in Q, f(p) \\cap f(p') = \\emptyset meaning that in fact the DFA is deterministic. To facilitate the semantic analogy, the code refers to transitions as edges in the remaining functions, without considering the case of a multigraph (remember that in a graph that is not a multigraph, there can only be one edge between two given nodes, and if there is more than one character that allows a transition between two states in the DFA, there will be more than one edge).","title":"DFA"},{"location":"structures/#substring-definitions","text":"pub struct SubstringDefinitions { pub substring_ranges: Vec<Set<(usize, usize)>>, pub substring_boundaries: Option<Vec<(Set(usize), Set(usize))>> } pub struct SubstringDefinitionsJson { pub transitions: Vec<Vec<(usize, usize)>> } The idea is to have a SubstringDefinitions structure for each of the public parts of the regular expression. Consider the context where we are merging a DFA N (the accumulated network) and M (corresponding to a public part). This M will have a range of the type Set<(usize, usize)> and a limit of the type (Set(usize), Set(usize)) . The limit is called so because when merging the network N and the public M , where m is the maximum state index in N , it is understood that m is the \"limit\" between N and M (as the states of M are renamed to have indices \\geq m ). The range indicates the set of public edges in M and is essentially all its edges. That is, a set of pairs of DFAStateNode.state_id . We store this for future use, for the circuit generation. Since m is an index in both DFAs, and particularly the initial state of M , we have the classic DFA concatenation problem: obtaining NM (concatenated) where we can only transition from N to M via m and not from any state in F_N , which is a problem regardless of whether m \\in F_N . The proposed solution is to replace in M each edge that includes m as follows: \\begin{aligned} m \\rightarrow q &\\text{ by } \\{f \\rightarrow q: f \\in F_N\\}, \\quad (q \\in Q_M \\setminus \\{m\\})\\\\ q \\rightarrow m &\\text{ by } \\{q \\rightarrow f: f \\in F_N\\}, \\\\ m \\rightarrow m &\\text{ by } \\{f \\rightarrow f': f,f' \\in F_N\\} \\end{aligned} and the resulting DFA is effectively the concatenation of N and M . The two sets of the limit indicate where the substring of the regular expression corresponding to this part begins and ends. The start is the set of DFAStateNode.state_id generated by the final states of N , and the end is the set generated by the final states of M . Thus, a substring matches this part if and only if when we start, we are in an index from the first set, and when we finish, we are in an index from the second set.","title":"Substring Definitions"}]}